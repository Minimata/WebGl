<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8"/>

    <script src="Tools/jquery-3.1.0.min.js"></script>
    <script src="Tools/gl-matrix-min.js"></script>
    <script src="Tools/debug/webgl-debug.js"></script>
    <script src="Tools/webglTools.js"></script>
    <script src="Tools/Camera.js"></script>

    <script src="InputHandling/KeyboardHandling.js"></script>
    <script src="InputHandling/mouseMotionHandling.js"></script>

    <script src="Views/Scene.js"></script>
    <script src="Controllers/Controller.js"></script>

    <script src="Objects/Datas/Drawable.js"></script>
    <script src="Objects/Datas/Quad.js"></script>
    <script src="Objects/Interfaces/DrawableInterface.js"></script>
    <script src="Objects/Interfaces/QuadInterface.js"></script>

    <script id="preprocess-vs" type="x-shader/x-vertex">
//Quad attributes
attribute vec3 aVertexPosition;
attribute vec4 aColor;

//Projection and world rendering
uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;

//Values sent to frag
varying vec3 vVertexPos;
varying vec4 vColor;


void main(void) {
    //Setting the values sent to frag
    vColor = aColor;
    vVertexPos = aVertexPosition;

    //Rendering final positions of vertices in world
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
}
    </script>


    <script id="preprocess-fs" type="x-shader/x-fragment">



#ifdef GL_ES
    precision highp float;
#endif

#define PI 3.14159265358979323846264338327950288419716939937510
#define G 9.81
#define E 2.71828182845904523536028747135266249775724709369995
#define DEPTH 100.0
#define NUM_WAVES 7
#define NUM_GERS_WAVES 1


//Getting variables from vertex shader
varying vec4 vColor;
varying vec3 vVertexPos;

//Getting timestamps
uniform float uDeltaTime;
uniform float uFullTime;

uniform vec3 uCameraPosition;

vec3 uDirectionalLight = normalize(vec3(1.0, 1.0, 3.0));
float uDepthOfView = 100.0;


//Defining a wave
struct Wave {
    //arguments for position function
    vec2 position;
    vec2 center;
    vec2 stretch;

    //arguments for wave function
    float revolvingColor;
    float frequency;
    float amplitude;
    float offset;
    float speed;
};


//Colorful simple waves
float addValueWithLimit(float inputValue, float offset, float min, float max, float factorFirst, float factorSecond) {
    float newVal = factorFirst * inputValue + factorSecond * offset / (factorFirst + factorSecond);
    if(newVal > max) {
        newVal = max;
    }
    else if(newVal < min) {
        newVal = min;
    }
    return newVal;
}

float f_circular(vec2 val, vec2 center, vec2 stretch) {
    float xValue = (val.x - center.x);
    float yValue = (val.y - center.y);

    return sqrt(stretch.x*pow(xValue, 2.0) + stretch.y*pow(yValue, 2.0));
}

float wave(float initValue, float pos, float frequency, float amplitude, float offset, float speed) {
    float pulsation = 2.0*PI*frequency;
    float valueToAdd = amplitude*sin(radians(pulsation*pos + speed*uFullTime) + offset);

    return addValueWithLimit(initValue, valueToAdd, 0.0, 1.0, 1.0, 1.0);
}

float getValueFromWave(Wave w, float aFactor, float fFactor, float oFactor, float sFactor) {
    float tmpPos = f_circular(w.position, w.center, w.stretch);
    return wave(w.revolvingColor, tmpPos, fFactor*w.frequency, aFactor*w.amplitude, oFactor*w.offset, sFactor*w.speed);
}

//Gerstner waves
struct GerstnerWave {
    vec2 direction;
    float amplitude;
    float steepness;
    float speed;
};

float tanh(float seed) {
    return (pow(E, 2.0*seed) - 1.0)/(pow(E, 2.0*seed) + 1.0);
}

struct Surface {
    vec3 pos;
    vec3 norm1;
    vec3 norm2;
};


Surface gerstnerWave(vec3 inputVector, GerstnerWave wave) {

    vec2 wavenumber = 0.4435*wave.steepness*normalize(wave.direction);
//    float dirLength = length(wave.direction);
//    wave.direction = normalize(wave.direction);
//    wavenumber = wave.direction * wave.steepness / (wave.amplitude);


    float km = sqrt(pow(wavenumber.x, 2.0) + pow(wavenumber.y, 2.0));
    float wm = G*km*tanh(km*DEPTH);
    float theta = wavenumber.x*inputVector.x + wavenumber.y*inputVector.y - wave.speed*wm*uFullTime;

    vec3 newVector = inputVector;
    newVector.x = (wavenumber.x * wave.amplitude * sin(theta)) / (km*tanh(km * DEPTH));
    newVector.y = (wavenumber.y * wave.amplitude * sin(theta)) / (km* tanh(km * DEPTH));
    newVector.z = wave.amplitude * cos(theta);

    vec3 norm1 = vec3(  (pow(wavenumber.x, 2.0) * wave.amplitude * cos(theta)) / (km* tanh(km*DEPTH)),
                        (wavenumber.x * wavenumber.y * wave.amplitude * cos(theta)) / (km* tanh(km * DEPTH)),
                        (wavenumber.x * wave.amplitude * sin(theta)));

    vec3 norm2 = vec3(  (wavenumber.x * wavenumber.y * wave.amplitude * cos(theta)) / (km* tanh(km*DEPTH)),
                        (pow(wavenumber.y, 2.0) * wave.amplitude * cos(theta)) / (km* tanh(km * DEPTH)),
                        (wavenumber.y * wave.amplitude * sin(theta)));

    return Surface(newVector, norm1, norm2);
}

// sky
vec3 getSkyColor(vec3 e) {
    e.y = max(e.y,0.0);
    vec3 ret;
    ret.x = pow(1.0-e.y,2.0);
    ret.y = 1.0-e.y;
    ret.z = 0.6+(1.0-e.y)*0.4;
    return ret;
}

void main(void) {

    //sky
    vec2 uv = vVertexPos.xy;
    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;

    //Common color waves
    vec4 color = vColor;
    float valueAtI;
    float commonFrequencyFactor = 2.0;
    float commonAmplitudeFactor = 1.8;
    float commonOffsetFactor = 1.0;
    float commonSpeedFactor = 0.5;
    float commonStretchFactor = 0.01;

    Wave allWaves[NUM_WAVES];
    allWaves[0] = Wave(vVertexPos.xy, vec2(4000.0, 7000.0), commonStretchFactor*vec2(0.01, 0.01), vColor[0], 5.0, 0.6, 0.0, 100.0);
    allWaves[1] = Wave(vVertexPos.xy, vec2(4000.0, 3000.0), commonStretchFactor*vec2(0.005, 0.01), vColor[0], 7.0, 0.5, 0.0, 150.0);
    allWaves[2] = Wave(vVertexPos.xy, vec2(-5000.0, 0.0), commonStretchFactor*vec2(0.005, 0.05), vColor[0], 6.0, 0.3, 0.0, 70.0);
    allWaves[3] = Wave(vVertexPos.xy, vec2(-5000.0, -5000.0), commonStretchFactor*vec2(0.001, 0.001), vColor[0], 10.0, 0.1, 0.0, 50.0);
    allWaves[4] = Wave(vVertexPos.xy, vec2(-2000.0, 7000.0), commonStretchFactor*vec2(0.02, 0.02), vColor[0], 8.0, 0.15, 0.0, 70.0);
    allWaves[5] = Wave(vVertexPos.xy, vec2(-5000.0, 4000.0), commonStretchFactor*vec2(0.01, 0.01), vColor[0], 10.0, 0.1, 0.0, 50.0);
    allWaves[6] = Wave(vVertexPos.xy, vec2(0.0, 0.0), commonStretchFactor*vec2(0.001, 0.001), vColor[0], 1.0, 0.8, 0.0, 30.0);

    for(int i = 1; i < 3; i++) {
        valueAtI = 0.0;

        for(int j = 0; j < NUM_WAVES; j++){
            allWaves[j].revolvingColor = vColor[i];
            valueAtI += getValueFromWave(allWaves[j], commonAmplitudeFactor, commonFrequencyFactor, commonOffsetFactor, commonSpeedFactor);
        }
        color[i] = valueAtI / float(NUM_WAVES);
    }


    //Gerstner displaced waves
    float ampFactor = 2.0;
	float speedFactor = 1.0;

    GerstnerWave allGersWaves[NUM_GERS_WAVES];
    allGersWaves[0] = GerstnerWave(vec2(1, 2), ampFactor, 1.0, speedFactor);
//    allGersWaves[0] = GerstnerWave(0.1*vec2(1, 2), 1.2*ampFactor, 0.0, speedFactor);
//    allGersWaves[1] = GerstnerWave(0.5*vec2(0.013, 0.017), 0.7*ampFactor, 0.0, speedFactor);
//    allGersWaves[2] = GerstnerWave(0.2*vec2(-0.7, 0.9), 0.6*ampFactor, 0.0, speedFactor);
//    allGersWaves[3] = GerstnerWave(0.3*vec2(0.3, -0.5), ampFactor, 0.0, speedFactor);
//    allGersWaves[4] = GerstnerWave(0.1*vec2(-1, 1), 1.0*ampFactor, 0.0, speedFactor);
//    allGersWaves[5] = GerstnerWave(0.1*vec2(PI, -1), 0.6*ampFactor, 0.0, speedFactor);

    vec3 tmpPos = vec3(0.0);
    vec3 tmpNorm1 = vec3(0.0);
    vec3 tmpNorm2 = vec3(0.0);
    for(int i = 0; i < NUM_GERS_WAVES; i++){
        Surface s = gerstnerWave(vVertexPos, allGersWaves[i]);
        tmpPos += s.pos;
        tmpNorm1 += s.norm1;
        tmpNorm2 += s.norm2;
    }

    //Creating height map
    //This here can't work - need to be between 0 and 1 and keep proprtions of different amplitudes between waves
    float height = tmpPos.z;

    //Creating normal map
    vec3 normal1 = vec3(1.0 - tmpNorm1.x, -tmpNorm1.y, -tmpNorm1.z);
    vec3 normal2 = vec3(-tmpNorm2.x, 1.0 - tmpNorm2.y, -tmpNorm2.z);
    vec3 normal = -normalize(cross(normal2, normal1));

    //Creating depth map
    vec3 absPos = vVertexPos + tmpPos;
    float depth = (-1.0 / uDepthOfView)*length(absPos - uCameraPosition) + 1.0;

	vec4 normalMap = normalize(vec4(vec3(normal.x + 0.5, normal.y + 0.5, normal.z), 1.0));
	vec4 depthMap = vec4(vec3(depth), 1.0); //can't use it with FBO like this
	vec4 heightMap = vec4(vec3(absPos.z / 10.0), 1.0);
    vec4 ambientMap = vec4(vColor.xyz*dot(normal, uDirectionalLight) / (length(normal) * length(uDirectionalLight)), 1.0);

//    vec3 finalColor = mix(
//        getSkyColor(dir),
//        color.xyz,
//    	pow(smoothstep(0.0,-0.05,dir.y),0.3));


    gl_FragColor = ambientMap;
}


    </script>

    <!-- vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">

//Quad attributes
attribute vec3 aVertexPosition;
attribute vec4 aColor;
attribute vec2 aTextureCoord;

//Projection and world rendering
uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

//Values sent to frag
varying vec3 vVertexPos;
varying vec4 vColor;
varying vec2 vTextureCoord;


void main(void) {
    //Setting the values sent to frag
    vColor = aColor;
    vVertexPos = aVertexPosition;
    vTextureCoord = aTextureCoord;

    //Rendering final positions of vertices in world
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
}
    </script>




    <!-- fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">


#ifdef GL_ES
    precision highp float;
#endif

uniform sampler2D uSampler;

//Getting variables from vertex shader
varying vec4 vColor;
varying vec3 vVertexPos;
varying vec2 vTextureCoord;

void main(void) {
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
}
    </script>
</head>
<body>

<!-- webgl canvas -->
<canvas id="webgl-canvas" width="1280" height="800">
    HTML5 is not supported
</canvas>
</body>
</html>