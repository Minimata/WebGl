<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8"/>

    <script src="Tools/jquery-3.1.0.min.js"></script>
    <script src="Tools/gl-matrix-min.js"></script>
    <script src="Tools/debug/webgl-debug.js"></script>
    <script src="Tools/webglTools.js"></script>
    <script src="Tools/Camera.js"></script>

    <script src="InputHandling/KeyboardHandling.js"></script>
    <script src="InputHandling/mouseMotionHandling.js"></script>

    <script src="Views/Scene.js"></script>
    <script src="Controllers/Controller.js"></script>

    <script src="Objects/Datas/Drawable.js"></script>
    <script src="Objects/Datas/Quad.js"></script>
    <script src="Objects/Interfaces/DrawableInterface.js"></script>
    <script src="Objects/Interfaces/QuadInterface.js"></script>

    <script id="preprocess-vs" type="x-shader/x-vertex">

#extension GL_EXT_draw_buffers : require

//Quad attributes
attribute vec3 aVertexPosition;
attribute vec4 aColor;

//Projection and world rendering
uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;

//Values sent to frag
varying vec3 vVertexPos;
varying vec4 vColor;


void main(void) {
    //Setting the values sent to frag
    vColor = aColor;
    vVertexPos = aVertexPosition;

    //Rendering final positions of vertices in world
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
}
    </script>


    <script id="preprocess-fs" type="x-shader/x-fragment">

#extension GL_EXT_draw_buffers : require

#ifdef GL_ES
    precision highp float;
#endif

#define PI 3.14159265358979323846264338327950288419716939937510
#define G 9.81
#define E 2.71828182845904523536028747135266249775724709369995
#define DEPTH 100.0
#define NUM_WAVES 7
#define NUM_GERS_WAVES 4


//Getting variables from vertex shader
varying vec4 vColor;
varying vec3 vVertexPos;

//Getting timestamps
uniform float uDeltaTime;
uniform float uFullTime;

uniform vec3 uCameraPosition;

vec3 uDirectionalLight = normalize(vec3(1.0, 1.0, 3.0));
float uDepthOfView = 100.0;


//Defining a wave
struct Wave {
    //arguments for position function
    vec2 position;
    vec2 center;
    vec2 stretch;

    //arguments for wave function
    float revolvingColor;
    float frequency;
    float amplitude;
    float speed;
};


//Colorful simple waves
float addValueWithLimit(float inputValue, float offset, float min, float max, float factorFirst, float factorSecond) {
    float newVal = factorFirst * inputValue + factorSecond * offset / (factorFirst + factorSecond);
    if(newVal > max) {
        newVal = max;
    }
    else if(newVal < min) {
        newVal = min;
    }
    return newVal;
}

float f_circular(vec2 val, vec2 center, vec2 stretch) {
    float xValue = (val.x - center.x);
    float yValue = (val.y - center.y);

    return sqrt(stretch.x*pow(xValue, 2.0) + stretch.y*pow(yValue, 2.0));
}

float wave(float initValue, float pos, float frequency, float amplitude, float speed) {
    float pulsation = 2.0*PI*frequency;
    float valueToAdd = amplitude*sin(radians(pulsation*pos + speed*uFullTime));

    return addValueWithLimit(initValue, valueToAdd, 0.0, 1.0, 1.0, 1.0);
}

float getValueFromWave(Wave w, float aFactor, float fFactor, float oFactor, float sFactor) {
    float tmpPos = f_circular(w.position, w.center, w.stretch);
    return wave(w.revolvingColor, tmpPos, fFactor*w.frequency, aFactor*w.amplitude, sFactor*w.speed);
}
// sky
vec3 getSkyColor(vec3 e) {
    e.y = max(e.y,0.0);
    vec3 ret;
    ret.x = pow(1.0-e.y,2.0);
    ret.y = 1.0-e.y;
    ret.z = 0.6+(1.0-e.y)*0.4;
    return ret;
}

float tanh(float seed) {
    return (pow(E, 2.0*seed) - 1.0)/(pow(E, 2.0*seed) + 1.0);
}

//Gerstner waves
struct GerstnerWave {
    vec2 direction;
    float amplitude;
    float steepness;
    float speed;
    float relativeHeight;
    float frequency;
};

struct Surface {
    vec3 pos;
    vec3 norm1;
    vec3 norm2;
};


Surface gerstnerWave(vec3 inputVector, GerstnerWave wave) {

    vec2 wavenumber = 0.4435*wave.steepness*normalize(wave.direction);

    float km = sqrt(pow(wavenumber.x, 2.0) + pow(wavenumber.y, 2.0));
    float wm = G*km*tanh(km*DEPTH);
    float theta = wave.frequency*(wavenumber.x*inputVector.x + wavenumber.y*inputVector.y) - wave.speed*wm*uFullTime;

    vec3 newVector = inputVector;
    newVector.x = (wavenumber.x * wave.amplitude * sin(theta)) / (km*tanh(km * DEPTH));
    newVector.y = (wavenumber.y * wave.amplitude * sin(theta)) / (km* tanh(km * DEPTH));
    newVector.z = wave.relativeHeight * wave.amplitude * cos(theta);

    vec3 norm1 = vec3(  (pow(wavenumber.x, 2.0) * wave.amplitude * cos(theta)) / (km* tanh(km*DEPTH)),
                        (wavenumber.x * wavenumber.y * wave.amplitude * cos(theta)) / (km* tanh(km * DEPTH)),
                        (wave.relativeHeight * wavenumber.x * wave.amplitude * sin(theta)));

    vec3 norm2 = vec3(  (wavenumber.x * wavenumber.y * wave.amplitude * cos(theta)) / (km* tanh(km*DEPTH)),
                        (pow(wavenumber.y, 2.0) * wave.amplitude * cos(theta)) / (km* tanh(km * DEPTH)),
                        (wave.relativeHeight * wavenumber.y * wave.amplitude * sin(theta)));

    return Surface(newVector, norm1, norm2);
}

void main(void) {

    //sky
    vec2 uv = vVertexPos.xy;
    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;

    //Common color waves
    vec4 color = vColor;
    float valueAtI;
    float commonFrequencyFactor = 2.0;
    float commonAmplitudeFactor = 1.8;
    float commonOffsetFactor = 1.0;
    float commonSpeedFactor = 0.5;
    float commonStretchFactor = 0.01;
    float commomCenterFactor = 100.0;

    Wave allWaves[NUM_WAVES];
    allWaves[0] = Wave(vVertexPos.xy, commomCenterFactor * vec2(4.0, 7.0), commonStretchFactor*vec2(0.01, 0.01), vColor[0], commonFrequencyFactor * 5.0, commonAmplitudeFactor * 0.6, commonSpeedFactor * 100.0);
    allWaves[1] = Wave(vVertexPos.xy, commomCenterFactor * vec2(4.0, 3.0), commonStretchFactor*vec2(0.005, 0.01), vColor[0], commonFrequencyFactor * 7.0, commonAmplitudeFactor * 0.5, commonSpeedFactor * 150.0);
    allWaves[2] = Wave(vVertexPos.xy, commomCenterFactor * vec2(-5.0, 0.0), commonStretchFactor*vec2(0.005, 0.05), vColor[0], commonFrequencyFactor * 6.0, commonAmplitudeFactor * 0.3, commonSpeedFactor * 70.0);
    allWaves[3] = Wave(vVertexPos.xy, commomCenterFactor * vec2(-5.0, -5.0), commonStretchFactor*vec2(0.001, 0.001), vColor[0], commonFrequencyFactor * 10.0, commonAmplitudeFactor * 0.1, commonSpeedFactor * 50.0);
    allWaves[4] = Wave(vVertexPos.xy, commomCenterFactor * vec2(-2.0, 7.0), commonStretchFactor*vec2(0.02, 0.02), vColor[0], commonFrequencyFactor * 8.0, commonAmplitudeFactor * 0.15, commonSpeedFactor * 0.0);
    allWaves[5] = Wave(vVertexPos.xy, commomCenterFactor * vec2(-5.0, 4.0), commonStretchFactor*vec2(0.01, 0.01), vColor[0], commonFrequencyFactor * 10.0, commonAmplitudeFactor * 0.1, commonSpeedFactor * 50.0);
    allWaves[6] = Wave(vVertexPos.xy, commomCenterFactor * vec2(0.0, 0.0), commonStretchFactor*vec2(0.001, 0.001), vColor[0], commonFrequencyFactor * 1.0, commonAmplitudeFactor * 0.2, commonSpeedFactor * 30.0);

    for(int i = 1; i < 3; i++) {
        valueAtI = 0.0;

        for(int j = 0; j < NUM_WAVES; j++){
            allWaves[j].revolvingColor = vColor[i];
            valueAtI += getValueFromWave(allWaves[j], commonAmplitudeFactor, commonFrequencyFactor, commonOffsetFactor, commonSpeedFactor);
        }
        color[i] = valueAtI / float(NUM_WAVES);
    }


    //Gerstner displaced waves
    float ampFactor = 1.0; //between 0.0 and 2.0
    float steepFactor = 1.0; // between 0.0 and 1.0
	float speedFactor = 1.0; //whatever
	float heightFactor = 1.5; //whatever
	float frequencyFactor = 100.0; //whatever

    GerstnerWave allGersWaves[NUM_GERS_WAVES];
    allGersWaves[0] = GerstnerWave(vec2(-1, 1), ampFactor, 0.5*steepFactor, speedFactor, heightFactor, frequencyFactor);
    allGersWaves[1] = GerstnerWave(vec2(1, 1), 1.2*ampFactor, 0.7*steepFactor, 0.7*speedFactor, 1.2*heightFactor, 0.4*frequencyFactor);
    allGersWaves[2] = GerstnerWave(vec2(0.5, 1), 0.5*ampFactor, 0.5*steepFactor, 0.7*speedFactor, 1.5*heightFactor, 1.2*frequencyFactor);
    allGersWaves[3] = GerstnerWave(vec2(-2, 1), 1.2*ampFactor, 0.7*steepFactor, 0.1*speedFactor, 1.0*heightFactor, 0.7*frequencyFactor);

    vec3 tmpPos = vec3(0.0);
    vec3 tmpNorm1 = vec3(0.0);
    vec3 tmpNorm2 = vec3(0.0);
    for(int i = 0; i < NUM_GERS_WAVES; i++){
        Surface s = gerstnerWave(vVertexPos, allGersWaves[i]);
        tmpPos += s.pos;
        tmpNorm1 += s.norm1;
        tmpNorm2 += s.norm2;
    }

    //Creating height map
    //This here can't work - need to be between 0 and 1 and keep proprtions of different amplitudes between waves
    float height = tmpPos.z;

    //Creating normal map
    vec3 normal1 = vec3(1.0 - tmpNorm1.x, -tmpNorm1.y, -tmpNorm1.z);
    vec3 normal2 = vec3(-tmpNorm2.x, 1.0 - tmpNorm2.y, -tmpNorm2.z);
    vec3 normal = -normalize(cross(normal2, normal1));

    //Creating depth map
    vec3 absPos = vVertexPos + tmpPos;
    vec3 pointToCam = absPos - uCameraPosition;
    float depth = (-1.0 / uDepthOfView)*length(pointToCam) + 1.0;

    vec3 tmpMap = normalize(pointToCam);
    vec4 relativeNormalMap = normalize(vec4(vec3(tmpMap.x + 0.5, tmpMap.y + 0.5, tmpMap.z), 1.0));
    vec4 ambientMap = color;
	vec4 normalMap = normalize(vec4(vec3(normal.x + 0.5, normal.y + 0.5, normal.z), 1.0));
	vec4 depthMap = vec4(vec3(depth), 1.0);
	vec4 heightMap = vec4(vec3(absPos.z / 10.0), 1.0);
    vec4 diffuseMap = vec4(color.xyz*dot(normal, uDirectionalLight) / (length(normal) * length(uDirectionalLight)), 1.0);

//    vec3 finalColor = mix(
//        getSkyColor(dir),
//        color.xyz,
//    	pow(smoothstep(0.0,-0.05,dir.y),0.3));

    gl_FragData[0] = diffuseMap;
    gl_FragData[1] = normalMap;
    gl_FragData[2] = heightMap;
    gl_FragData[3] = relativeNormalMap;
//    gl_FragColor = diffuseMap;
}
    </script>

    <!-- vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">

#extension GL_EXT_draw_buffers : require

//Quad attributes
attribute vec3 aVertexPosition;
attribute vec4 aColor;
attribute vec2 aTextureCoord;

//Projection and world rendering
uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

//Values sent to frag
varying vec3 vVertexPos;
varying vec4 vColor;
varying vec2 vTextureCoord;


void main(void) {
    //Setting the values sent to frag
    vColor = aColor;
    vVertexPos = aVertexPosition;
    vTextureCoord = aTextureCoord;

    //Rendering final positions of vertices in world
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
}
    </script>




    <!-- fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">

#extension GL_EXT_draw_buffers : require

#ifdef GL_ES
    precision highp float;
#endif

uniform sampler2D uSampler;

//Getting variables from vertex shader
varying vec4 vColor;
varying vec3 vVertexPos;
varying vec2 vTextureCoord;

void main(void) {
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
}
    </script>
</head>
<body>

<!-- webgl canvas -->
<canvas id="webgl-canvas" width="1280" height="800">
    HTML5 is not supported
</canvas>
</body>
</html>