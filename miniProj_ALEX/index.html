<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8"/>

    <script src="Tools/jquery-3.1.0.min.js"></script>
    <script src="Tools/gl-matrix-min.js"></script>
    <script src="Tools/debug/webgl-debug.js"></script>
    <script src="Tools/webglTools.js"></script>
    <script src="Tools/Camera.js"></script>

    <script src="InputHandling/KeyboardHandling.js"></script>
    <script src="InputHandling/mouseMotionHandling.js"></script>

    <script src="Views/Scene.js"></script>
    <script src="Controllers/Controller.js"></script>

    <script src="Objects/Datas/Drawable.js"></script>
    <script src="Objects/Datas/Quad.js"></script>
    <script src="Objects/Interfaces/DrawableInterface.js"></script>
    <script src="Objects/Interfaces/QuadInterface.js"></script>

    <!-- vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">

//Quad attributes
attribute vec3 aVertexPosition;
attribute vec4 aColor;
uniform vec2 uCornerTopLeft;
uniform vec2 uCornerBottomLeft;
uniform vec2 uCornerTopRight;
uniform vec2 uCornerBottomRight;

//Projection and world rendering
uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

//Values sent to frag
varying vec3 vVertexPos;
varying vec4 vColor;

//Getting timestamps
uniform float uDeltaTime;
uniform float uFullTime;


void main(void) {
    //Setting the values sent to frag
    vColor = aColor;
    vVertexPos = aVertexPosition;

    //Rendering final positions of vertices in world
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
}
    </script>




    <!-- fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
#ifdef GL_ES
    precision highp float;
#endif

#define PI 3.14159265358979323846264338327950288419716939937510
#define G 9.81
#define E 2.71828182845904523536028747135266249775724709369995
#define DEPTH 10.0
#define NUM_WAVES 7
#define NUM_GERS_WAVES 3

//Getting variables from vertex shader
varying vec4 vColor;
varying vec3 vVertexPos;

//Getting timestamps
uniform float uDeltaTime;
uniform float uFullTime;

//Quad attributes
uniform vec2 uCornerTopLeft;
uniform vec2 uCornerBottomLeft;
uniform vec2 uCornerTopRight;
uniform vec2 uCornerBottomRight;

uniform vec3 uCameraPosition;


//Defining a wave
struct Wave {
    //arguments for position function
    vec2 position;
    vec2 center;
    vec2 stretch;

    //arguments for wave function
    float revolvingColor;
    float frequency;
    float amplitude;
    float offset;
    float speed;
};


//Colorful simple waves
float addValueWithLimit(float inputValue, float offset, float min, float max, float factorFirst, float factorSecond) {
    float newVal = factorFirst * inputValue + factorSecond * offset / (factorFirst + factorSecond);
    if(newVal > max) {
        newVal = max;
    }
    else if(newVal < min) {
        newVal = min;
    }
    return newVal;
}

float f_circular(vec2 val, vec2 center, vec2 stretch) {
    float xValue = (val.x - center.x);
    float yValue = (val.y - center.y);

    return sqrt(stretch.x*pow(xValue, 2.0) + stretch.y*pow(yValue, 2.0));
}

float wave(float initValue, float pos, float frequency, float amplitude, float offset, float speed) {
    float pulsation = 2.0*PI*frequency;
    float valueToAdd = amplitude*sin(radians(pulsation*pos + speed*uFullTime) + offset);

    return addValueWithLimit(initValue, valueToAdd, 0.0, 1.0, 1.0, 1.0);
}

float getValueFromWave(Wave w, float aFactor, float fFactor, float oFactor, float sFactor) {
    float tmpPos = f_circular(w.position, w.center, w.stretch);
    return wave(w.revolvingColor, tmpPos, fFactor*w.frequency, aFactor*w.amplitude, oFactor*w.offset, sFactor*w.speed);
}

//Gerstner waves
struct GerstnerWave {
    vec2 wavenumber;
    float amplitude;
    float phase;
    float speed;
};

float tanh(float seed) {
    return (pow(E, 2.0*seed) - 1.0)/(pow(E, 2.0*seed) + 1.0);
}

struct Surface {
    vec3 pos;
    vec3 norm1;
    vec3 norm2;
};


Surface gerstnerWave(vec3 inputVector, GerstnerWave wave) {

    float km = sqrt(pow(wave.wavenumber.x, 2.0) + pow(wave.wavenumber.y, 2.0));
    float wm = G*km*tanh(km*DEPTH);
    float theta = wave.wavenumber.x*inputVector.x + wave.wavenumber.y*inputVector.y - wave.speed*wm*uFullTime - wave.phase;

    vec3 newVector = inputVector;
    newVector.x = (wave.wavenumber.x * wave.amplitude * sin(theta)) / (km/* * tanh(km * DEPTH) */);
    newVector.y = (wave.wavenumber.y * wave.amplitude * sin(theta)) / (km/* * tanh(km * DEPTH) */);
    newVector.z = wave.amplitude * cos(theta);

    //keeping it between 0 and 1 instead of -amplitude and amplitude
    newVector.z += wave.amplitude;
    newVector.z /= 2.0;

    vec3 norm1 = vec3(  (pow(wave.wavenumber.x, 2.0) * wave.amplitude * cos(theta)) / (km/* * tanh(km*DEPTH)*/),
                        (wave.wavenumber.x * wave.wavenumber.y * wave.amplitude * cos(theta)) / (km/* * tanh(km * DEPTH)*/),
                        (wave.wavenumber.x * wave.amplitude * sin(theta)));
//    norm1.z += wave.amplitude;
//    norm1.z /= 2.0;

    vec3 norm2 = vec3(  (wave.wavenumber.x * wave.wavenumber.y * wave.amplitude * cos(theta)) / (km/* * tanh(km*DEPTH)*/),
                        (pow(wave.wavenumber.y, 2.0) * wave.amplitude * cos(theta)) / (km/* * tanh(km * DEPTH)*/),
                        (wave.wavenumber.y * wave.amplitude * sin(theta)));
//    norm2.z += wave.amplitude;
//    norm2.z /= 2.0;

    return Surface(newVector, norm1, norm2);
}


//Displacement mapping
float displace(vec3 point, vec3 normal) {
    vec3 pointToCamera = normalize(uCameraPosition - point);
    float angle = abs(acos(dot(pointToCamera, normal)));
    float proportion = angle / (PI / 2.0);
    float heightFromVector = pointToCamera.z;

    float a = normal.x;
    float b = normal.y;
    float c = normal.z;
    float d = -(a*point.x + b*point.y + c*point.z);
    float param = -(a*point.x + b*point.y + d) / (pointToCamera.x + pointToCamera.y + pointToCamera.z);
    vec3 intersection = param*pointToCamera;

    float heightFromIntersection = intersection.z;
    return ((1.0 - proportion)*heightFromVector + proportion*heightFromIntersection);
}



void main(void) {

    //Common color waves
    vec4 color = vColor;
    float valueAtI;
    float commonFrequencyFactor = 2.0;
    float commonAmplitudeFactor = 1.8;
    float commonOffsetFactor = 1.0;
    float commonSpeedFactor = 0.5;
    float commonStretchFactor = 0.01;

    Wave allWaves[NUM_WAVES];
    allWaves[0] = Wave(vVertexPos.xy, vec2(4000.0, 7000.0), commonStretchFactor*vec2(0.01, 0.01), vColor[0], 5.0, 0.6, 0.0, 100.0);
    allWaves[1] = Wave(vVertexPos.xy, vec2(4000.0, 3000.0), commonStretchFactor*vec2(0.005, 0.01), vColor[0], 7.0, 0.5, 0.0, 150.0);
    allWaves[2] = Wave(vVertexPos.xy, vec2(-5000.0, 0.0), commonStretchFactor*vec2(0.005, 0.05), vColor[0], 6.0, 0.3, 0.0, 70.0);
    allWaves[3] = Wave(vVertexPos.xy, vec2(-5000.0, -5000.0), commonStretchFactor*vec2(0.001, 0.001), vColor[0], 10.0, 0.1, 0.0, 50.0);
    allWaves[4] = Wave(vVertexPos.xy, vec2(-2000.0, 7000.0), commonStretchFactor*vec2(0.02, 0.02), vColor[0], 8.0, 0.15, 0.0, 70.0);
    allWaves[5] = Wave(vVertexPos.xy, vec2(-5000.0, 4000.0), commonStretchFactor*vec2(0.01, 0.01), vColor[0], 10.0, 0.1, 0.0, 50.0);
    allWaves[6] = Wave(vVertexPos.xy, vec2(0.0, 0.0), commonStretchFactor*vec2(0.001, 0.001), vColor[0], 1.0, 0.8, 0.0, 30.0);

    for(int i = 1; i < 3; i++) {
        valueAtI = 0.0;

        for(int j = 0; j < NUM_WAVES; j++){
            allWaves[j].revolvingColor = vColor[i];
            valueAtI += getValueFromWave(allWaves[j], commonAmplitudeFactor, commonFrequencyFactor, commonOffsetFactor, commonSpeedFactor);
        }
        color[i] = valueAtI / float(NUM_WAVES);
    }


    //Gerstner displaced waves

    float ampFactor = 2.0;

    GerstnerWave allGersWaves[NUM_GERS_WAVES];
    allGersWaves[0] = GerstnerWave(vec2(0.0, 0.1), ampFactor, 0.0, 1.0);
    allGersWaves[1] = GerstnerWave(vec2(0.013, 0.017), ampFactor, 0.0, 5.0);
    allGersWaves[2] = GerstnerWave(vec2(0.07, 0.11), 2.0*ampFactor, 0.0, 3.3);

    vec3 tmpPos = vec3(0.0);
    vec3 tmpNorm1 = vec3(0.0);
    vec3 tmpNorm2 = vec3(0.0);
    for(int i = 0; i < NUM_GERS_WAVES; i++){
        /*
        vVertexPos varry between 0 - 500 alongside x - y axis
        */
        Surface s = gerstnerWave(vVertexPos, allGersWaves[i]);
        tmpPos += s.pos;
        tmpNorm1 += s.norm1;
        tmpNorm2 += s.norm2;
    }

    vec3 normal1 = vec3(1.0 - tmpNorm1.x, -tmpNorm1.y, -tmpNorm1.z);
    vec3 normal2 = vec3(-tmpNorm2.x, 1.0 - tmpNorm2.y, -tmpNorm2.z);
    vec3 normal = -normalize(cross(normal2, normal1));
    vec3 displacementPoint = vVertexPos + tmpPos;
    float heightVisibleAtPoint = displace(displacementPoint, normal);
    color = vec4(normal.x + 0.5, normal.y + 0.5,normal.z, 1.0);
//    color = vec4(tmpPos.xy, heightVisibleAtPoint, 1.0);
    //Set the color of actual pixel at the color
    gl_FragColor = color;
}
    </script>
</head>
<body>

<!-- webgl canvas -->
<canvas id="webgl-canvas" width="1280" height="800">
    HTML5 is not supported
</canvas>
</body>
</html>